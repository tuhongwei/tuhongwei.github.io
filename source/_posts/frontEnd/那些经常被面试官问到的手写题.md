---
title: 那些经常被面试官问到的手写题
date: 2021-02-25 15:36:12
author: Twittytop
categories:
- 前端
tags:
- JavaScript
keywords: instanceof new bind call Promise debounce throttle
---

### 1. 实现 instanceof 运算符

instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上，运算符左侧是实例对象，右侧是构造函数。

```javascript
const iInstanceof = function (left, right) {
	let proto = Object.getPrototypeOf(left);
 	while (true) {
        if (proto === null) return false;
        if (proto === right.prototype) return true;
        proto = Object.getPrototypeOf(proto);
    }
};
```



### 2. 实现 new 操作符

new 执行过程如下：

1. 创建一个新对象；

2. 新对象的[[prototype]]特性指向构造函数的prototype属性；

3. 构造函数内部的this指向新对象；

4. 执行构造函数；

5. 如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象；

   

```javascript
const iNew = function (fn, ...rest) {
	let instance = Object.create(fn.prototype);
    let res = fn.apply(instance, rest);
    return res !== null && (typeof res === 'object' || typeof res === 'function') ? res : instance;
};
```



### 3. 实现 Object.assign 方法

浅拷贝方法，只会拷贝源对象自身的且可枚举的属性（包括以 Symbol 为 key 的属性）到目标对象

```javascript
const iAssign = function (target, ...source) {
    if (target === null || target === undefined) {
        throw new TypeError('Cannot convert undefined or null to object');
    }
    let res = Object(target);
    for (let i = 1; i < arguments.length; i++) {
        let source = arguments[i];
        if (source !== undefined && source !== null) {
            let keys = [...Object.keys(source), ...Object.getOwnPropertySymbols(source)];
            for (const k of keys) {
                if (source.propertyIsEnumerable(k)) {
                    res[k] = source[k];
                }
            }
        }
    }
    return res;
};
// 保持 assign 的数据属性一致
Object.defineProperty(Object, 'iAssign', {
    value: iAssign,
    configurable: true,
    enumerable: false,
    writable: true
});
```



### 4. bind 方法

改变函数内 this 的值并且传参，返回一个函数

```javascript
const iBind = function (thisArg, ...args) {
    const originFunc = this;
    const boundFunc = function (...args1) {
        // 解决 bind 之后对返回函数 new 的问题
        if (new.target) {
            if (originFunc.prototype) {
                boundFunc.prototype = originFunc.prototype;
            }
            const res = originFunc.apply(this, args.concat(args1));
            return res !== null && (typeof res === 'object' || typeof res === 'function') ? res : this;
        } else {
            return originFunc.apply(thisArg, args.concat(args1));
        }
    };
    // 解决length 和 name 属性问题
    const desc = Object.getOwnPropertyDescriptors(originFunc);
    Object.defineProperties(boundFunc, {
        length: Object.assign(desc.length, {
            value: desc.length < args.length ? 0 : (desc.length - args.length)
        }),
        name: Object.assign(desc.name, {
            value: `bound ${desc.name.value}`
        })
    });
    return boundFunc;
};
// 保持 bind 的数据属性一致
Object.defineProperty(Function.prototype, 'iBind', {
    value: iBind,
    enumerable: false,
    configurable: true,
    writable: true
});
```



### 5. call 方法

用指定的 this 值和参数来调用函数

```javascript
const iCall = function (thisArg, ...args) {
    thisArg = (thisArg === undefined || thisArg === null) ? window : Object(thisArg);
    let fn = Symbol('fn');
    thisArg[fn] = this;
    let res =  thisArg[fn](...args);
    delete thisArg[fn];
    return res;
};
// 保持 call 的数据属性一致
Object.defineProperty(Function.prototype, 'iCall', {
    value: iCall,
    configurable: true,
    enumerable: false,
    writable: true
});
```



### 6. 函数柯里化

将一个多参数函数转化为多个嵌套的单参数函数。

```javascript
const curry = function (targetFn) {
	return function fn (...rest) {
    	if (targetFn.length === rest.length) {
            return targetFn.apply(null, rest);
        }  else {
            return fn.bind(null, ...rest);
        }
    };
};
// 用法
function add (a, b, c, d) {
    return a + b + c + d;
}
console.log('柯里化：', curry(add)(1)(2)(3)(4)); 
// 柯里化： 10
```



### 7. 函数防抖 debounce 方法

```javascript
const debounce = function (func, wait = 0, options = {
    leading: true,
    context: null
}) {
    let timer;
    let res;
    const _debounce = function (...args) {
        options.context || (options.context = this);
        if (timer) {
           clearTimeout(timer);
        }
        if (options.leading && !timer) {
            timer = setTimeout(() => {
                timer = null;
            }, wait);
            res = func.apply(options.context, args);
        } else {
            timer = setTimeout(() => {
               res = func.apply(options.context, args);
               timer = null;
           }, wait);
        }
        return res;
    };
    _debounce.cancel = function () {
        clearTimeout(timer);
        timer = null;
    };
    return _debounce;
};
```

leading 表示进入时是否立即执行，如果在wait 时间内触发事件，则会将上一个定时器清除，并重新再设置一个 wait 时间的定时器。



### 8. 函数节流 throttle 方法

```javascript
const throttle = function (func, wait = 0, options = {
    leading: true,
    trailing: false,
    context: null
}) {
    let timer;
    let res;
    let previous = 0;
    const _throttle = function (...args) {
        options.context || (options.context = this);
        let now = Date.now();
        if (!previous && !options.leading) previous = now;
        if (now - previous >= wait) {
            if (timer) {
                clearTimeout(timer);
                timer = null;
            }
            res = func.apply(options.context, args);
            previous = now;
        } else if (!timer && options.trailing) {
            timer = setTimeout(() => {
                res = func.apply(options.context, args);
                previous = 0;
                timer = null;
           }, wait);
        }
        return res;
    };
    _throttle.cancel = function () {
        previous = 0;
        clearTimeout(timer);
        timer = null;
    };
    return _throttle;
};
```

函数节流就像水龙头滴水一样，间隔 wait 时间就会触发一次，这里相比函数防抖新增了 trailing 选项，表示是否在最后额外触发一次。



### 9. 事件发布订阅（eventBus 事件总线）



### 10. 深拷贝



### 11. class 的实现



### 12. 图片懒加载

```javascript
// 获取窗口高度
function getWindowHeight () {
    return window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
}

function getTop (e) {
    let t = e.offsetTop;
    while (e = e.offsetParent) {
        t += e.offsetTop;
    }
    return t;
}

const delta = 30;
let count = 0;
function lazyLoad (imgs) {
    const winH = getWindowHeight();
    const s = document.documentElement.scrollTop || document.body.scrollTop;
    for (let i = 0, l = imgs.length; i < l; i++) {
        if (winH + s + delta > getTop(imgs[i])) {
            if (!imgs[i].src) {
                imgs[i].src = imgs[i].getAttribute('data-src');
            	count++;
            }
            if (count === l) {
                window.removeEventListener('scroll', handler);
                window.removeEventListener('load', handler);
            }
        }
    }	
}
const imgs = document.querySelectorAll('img');
const handler = function () {
    lazyLoad(imgs);
};
window.addEventListener('scroll', handler);
window.addEventListener('load', handler);
```



当然你也可以用 getBoundingClientRect 方法：

```javascript
// 获取窗口高度
function getWindowHeight () {
    return window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
}

const delta = 30;
let count = 0;
function lazyLoad (imgs) {
    const winH = getWindowHeight();
    for (let i = 0, l = imgs.length; i < l; i++) {
        const rect = imgs[i].getBoundingClientRect();
        if (winH + delta > rect.top && rect.bottom > -delta) {
            if (!imgs[i].src) {
                imgs[i].src = imgs[i].getAttribute('data-src');
            	count++;
            }
            if (count === l) {
                window.removeEventListener('scroll', handler);
                window.removeEventListener('load', handler);
            }
        }
    }	
}
const imgs = document.querySelectorAll('img');
const handler = function () {
    lazyLoad(imgs);
};
window.addEventListener('scroll', handler);
window.addEventListener('load', handler);
```



当然你也可以用 IntersectionObserver 方法:

```javascript
function lazyLoad (imgs) {
    let options = {
        rootMargin: '30px'
    };
    let count = 0;
    let observer = new IntersectionObserver(entries => {
        entries.forEach(entry => {
            if (entry.intersectionRatio > 0) {
                entry.target.src = entry.target.getAttribute('data-src');
                count++;
                observer.unobserve(entry.target);
                if (count === imgs.length) {
                    window.removeEventListener('load', handler);
                }
            }
        });
    }, options);
    for (let i = 0; i < imgs.length; i++) {
        observer.observe(imgs[i]);
    }
}
const imgs = document.querySelectorAll('img');
const handler = function () {
    lazyLoad(imgs);
};
window.addEventListener('load', handler);
```



### 13. 实现Object.is 方法

Object.is() 和 === 的区别是 Object.is(0, -0) 返回 false, Object.is(NaN, NaN) 返回 true。

```javascript
const iIs = function (x, y) {
    if (x === y) {
        return x !== 0 || 1 / x === 1 / y;
    } else {
        return x !== x && y !== y;
    }
}
// 保持 is 的数据属性一致
Object.defineProperty(Function.prototype, 'iIs', {
    value: iIs,
    configurable: true,
    enumerable: false,
    writable: true
});
```



### 14. 时间切片

把长任务切割成多个小任务，使用场景是防止一个任务执行时间过长而阻塞线程

```javascript
function ts (gen) {
    if(typeof gen === 'function') gen = gen();
    if(!gen || typeof gen.next !== 'function') return;
    (function next() {
        const start = performance.now();
        let res = null;
        do {
            res = gen.next();
        } while(!res.done && performance.now() - start < 25)
        if (res.done) return;
        setTimeout(next);
    })();
}

// 用法
ts(function* () {
    const start = performance.now();
    while (performance.now() - start < 1000) {
        yield;
    }
    console.log('done!');
});
```



### 15. 单例模式

```javascript
const getSingleton = function (fn) {
    let instance;
    return function () {
        return instance || (instance = new (fn.bind(this, ...arguments))());
    };
};
// 用法
function Person (name) {
    this.name = name;
}
let singleton = getSingleton(Person);
let instance1 = new singleton('Twittop1');
let instance2 = new singleton('Twittop2');
console.log(instance1 === instance2); // true
```



当然你也可以用 ES6 的 Proxy 实现：

```javascript
const getSingleton = function (fn) {
    let instance;
    const handler = {
        construct (target, argumentsList) {
           return instance || (instance = Reflect.construct(target, argumentsList)); 
        }
    }
    return new Proxy(fn, handler);
};
// 用法
function Person (name) {
    this.name = name;
}
let singleton = getSingleton(Person);
let instance1 = new singleton('Twittop1');
let instance2 = new singleton('Twittop2');
console.log(instance1 === instance2); // true
```



### 16. Promise



参考资料

https://juejin.cn/post/6844903856489365518

https://github.com/berwin/time-slicing 

