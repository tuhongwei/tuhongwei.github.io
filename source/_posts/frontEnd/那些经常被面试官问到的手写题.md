---
title: 那些经常被面试官问到的手写题
date: 2021-02-25 15:36:12
author: Twittytop
categories:
- 前端
tags:
- JavaScript
keywords: instanceof new bind call Promise debounce throttle
---

### 1. 实现 instanceof 运算符

instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上，运算符左侧是实例对象，右侧是构造函数。

```javascript
const iInstanceof = function (left, right) {
	let proto = Object.getPrototypeOf(left);
 	while (true) {
        if (proto === null) return false;
        if (proto === right.prototype) return true;
        proto = Object.getPrototypeOf(proto);
    }
};
```



### 2. 实现 new 操作符

new 执行过程如下：

1. 创建一个新对象；

2. 新对象的[[prototype]]特性指向构造函数的prototype属性；

3. 构造函数内部的this指向新对象；

4. 执行构造函数；

5. 如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象；

   

```javascript
const iNew = function (fn, ...rest) {
	let instance = Object.create(fn.prototype);
    let res = fn.apply(instance, rest);
    return res !== null && (typeof res === 'object' || typeof res === 'function') ? res : instance;
};
```



### 3. 实现 Object.assign 方法

浅拷贝方法，只会拷贝源对象自身的并且可枚举的属性到目标对象

```javascript
const iAssign = function (target, ...source) {
    if (target === null || target === undefined) {
        throw new TypeError('Cannot convert undefined or null to object');
    }
    let res = Object(target);
    for (let i = 1; i < arguments.length; i++) {
        let source = arguments[i];
        if (source !== undefined && source !== null) {
            let keys = [...Object.keys(source), ...Object.getOwnPropertySymbols(source)];
            for (const k of keys) {
                if (source.propertyIsEnumerable(k)) {
                    res[k] = source[k];
                }
            }
        }
    }
    return res;
};
// 保持 assign 的数据属性一致
Object.defineProperty(Object, "iAssign", {
    value: iAssign,
    configurable: true,
    enumerable: false,
    writable: false
});
```



### 4. bind 方法

改变函数内 this 的值并且传参

```javascript
const iBind = function (thisArg, ...args) {
    const originFunc = this;
    const boundFunc = function (...args1) {
        // 解决 bind 之后对返回函数 new 的问题
        if (new.target) {
            if (originFunc.prototype) {
                boundFunc.prototype = originFunc.prototype;
            }
            const res = originFunc.apply(this, args.concat(args1));
            return res !== null && (typeof res === 'object' || typeof res === 'function') ? res : this;
        } else {
            return originFunc.apply(thisArg, args.concat(args1));
        }
    };
    // 解决length 和 name 属性问题
    const desc = Object.getOwnPropertyDescriptors(originFunc);
    Object.defineProperties(boundFunc, {
        length: Object.assign(desc.length, {
            value: desc.length < args.length ? 0 : (desc.length - args.length)
        }),
        name: Object.assign(desc.name, {
            value: `bound ${desc.name.value}`
        })
    });
    return boundFunc;
};
// 保持 bind 的数据属性一致
Object.defineProperty(Function.prototype, 'iBind', {
    value: iBind,
    enumerable: false,
    configurable: true,
    writable: true
});
```



### 5. call 方法

### 6. 函数柯里化

将一个多参数函数转化为多个嵌套的单参数函数。

```javascript
const curry = function (targetFn) {
	return function fn (...rest) {
    	if (targetFn.length === rest.length) {
            return targetFn.apply(null, rest);
        }  else {
            return fn.bind(null, ...rest);
        }
    };
};
// 用法
function add (a, b, c, d) {
    return a + b + c + d;
}
console.log('柯里化：', curry(add)(1)(2)(3)(4)); 
// 柯里化： 10
```

### 函数防抖 debounce 方法

### 函数节流 throttle 方法

### 事件发布订阅

### Promise



参考资料 https://juejin.cn/post/6844903856489365518

